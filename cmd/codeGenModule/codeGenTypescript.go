package codeGenModule

import (
	"fmt"
	"strings"
)

func generateTypescriptClass(componentName string, component Integration, kind string) string {
	var sb strings.Builder

	sb.WriteString("// PLEASE DO NOT EDIT THIS FILE, THIS IS GENERATED BY NATIVEBLOCKS\n\n")

	sb.WriteString("interface IProperty {\n")
	if kind == "BLOCK" {
		sb.WriteString("  key: string;\n")
		sb.WriteString("  valueMobile: string;\n")
		sb.WriteString("  valueTablet: string;\n")
		sb.WriteString("  valueDesktop: string;\n")
		sb.WriteString("  type: string;\n")
	} else {
		sb.WriteString("  key: string;\n")
		sb.WriteString("  value: string;\n")
		sb.WriteString("  type: string;\n")
	}
	sb.WriteString("}\n\n")

	sb.WriteString("interface IData {\n")
	sb.WriteString("  key: string;\n")
	sb.WriteString("  value: string;\n")
	sb.WriteString("  type: string;\n")
	sb.WriteString("}\n\n")

	if kind == "BLOCK" {
		sb.WriteString("interface IAction {\n")
		sb.WriteString("  event: string;\n")
		sb.WriteString("  triggers: any[];\n")
		sb.WriteString("}\n\n")

		sb.WriteString("interface ISlot {\n")
		sb.WriteString("  slot: string;\n")
		sb.WriteString("}\n\n")
	} else {
		sb.WriteString("interface ITrigger {\n")
		sb.WriteString("  name: string;\n")
		sb.WriteString("  keyType: string;\n")
		sb.WriteString("  then: string;\n")
		sb.WriteString("  properties: IProperty[];\n")
		sb.WriteString("  data: IData[];\n")
		sb.WriteString("  triggers: ITrigger[];\n")
		sb.WriteString("}\n\n")
	}

	sb.WriteString("interface IEvent {\n")
	sb.WriteString("  event: string;\n")
	sb.WriteString("}\n\n")

	sb.WriteString(fmt.Sprintf("export class %s {\n", componentName))

	sb.WriteString("  private readonly keyType: string;\n")
	sb.WriteString("  private readonly integrationVersion: number;\n")
	sb.WriteString("  private properties: IProperty[];\n")
	sb.WriteString("  private data: IData[];\n")
	sb.WriteString("  private readonly events: IEvent[];\n")

	if kind == "BLOCK" {
		sb.WriteString("  private actions: IAction[];\n")
		sb.WriteString("  private blocks: any[];\n")
		sb.WriteString("  private readonly slots: ISlot[];\n")
		sb.WriteString("  private readonly visibilityKey: string;\n")
		sb.WriteString("  private readonly slot: string;\n")
		sb.WriteString("  private readonly key: string;\n")
	} else {
		sb.WriteString("  private triggers: ITrigger[];\n")
		sb.WriteString("  private readonly name: string;\n")
		sb.WriteString("  private readonly then: string;\n")
	}

	sb.WriteString("\n  constructor(config: {\n")
	if kind == "BLOCK" {
		sb.WriteString("    key: string;\n")
		sb.WriteString("    visibilityKey: string;\n")
		sb.WriteString("    slot: string;\n")
	} else {
		sb.WriteString("    name: string;\n")
		sb.WriteString("    then: string;\n")
	}
	sb.WriteString("  } = {} as any) {\n")

	sb.WriteString(fmt.Sprintf("    this.keyType = \"%s\";\n", component.KeyType))

	if kind == "BLOCK" {
		sb.WriteString("    this.key = config.key;\n")
		sb.WriteString("    this.visibilityKey = config.visibilityKey;\n")
		sb.WriteString("    this.slot = config.slot;\n")
		sb.WriteString("    this.actions = [];\n")
		sb.WriteString("    this.blocks = [];\n")
		sb.WriteString("    this.slots = [];\n")
	} else {
		sb.WriteString("    this.triggers = [];\n")
		sb.WriteString("    this.name = config.name;\n")
		sb.WriteString("    this.then = config.then;\n")
	}

	sb.WriteString(fmt.Sprintf("    this.integrationVersion = %v;\n", component.Version))
	sb.WriteString("    this.properties = [];\n")
	sb.WriteString("    this.data = [];\n")
	sb.WriteString("    this.events = [];\n")

	sb.WriteString("    const initialProperties: IProperty[] = [\n")
	for _, prop := range component.Properties {
		if kind == "BLOCK" {
			sb.WriteString(fmt.Sprintf("      { key: \"%s\", valueMobile: \"%s\", valueTablet: \"%s\", valueDesktop: \"%s\", type: \"%s\" },\n",
				prop.Key,
				prop.Value,
				prop.Value,
				prop.Value,
				prop.Type))
		} else {
			sb.WriteString(fmt.Sprintf("      { key: \"%s\", value: \"%s\", type: \"%s\" },\n",
				prop.Key,
				prop.Value,
				prop.Type))
		}
	}
	sb.WriteString("    ];\n")
	sb.WriteString("    this.properties.push(...initialProperties);\n")

	sb.WriteString("    const initialData: IData[] = [\n")
	for _, data := range component.Data {
		sb.WriteString(fmt.Sprintf("      { key: \"%s\", value: null, type: \"%s\" },\n", data.Key, data.Type))
	}
	sb.WriteString("    ];\n")
	sb.WriteString("    this.data.push(...initialData);\n")

	if kind == "BLOCK" {
		sb.WriteString("    const initialSlots: ISlot[] = [\n")
		for _, slot := range component.Slots {
			sb.WriteString(fmt.Sprintf("      { slot: \"%s\" },\n", slot.Slot))
		}
		sb.WriteString("    ];\n")
		sb.WriteString("    this.slots.push(...initialSlots);\n")
	}

	sb.WriteString("    const initialEvents: IEvent[] = [\n")
	if kind != "BLOCK" && len(component.Events) == 0 {
		sb.WriteString("      { event: \"END\" },\n")
	} else {
		for _, event := range component.Events {
			sb.WriteString(fmt.Sprintf("      { event: \"%s\" },\n", event.Event))
		}
	}
	sb.WriteString("    ];\n")
	sb.WriteString("    this.events.push(...initialEvents);\n")
	sb.WriteString("  }\n\n")

	sb.WriteString("  private isValidEvent(eventName: string): boolean {\n")
	sb.WriteString("    return this.events.some((e) => e.event === eventName);\n")
	sb.WriteString("  }\n\n")

	if kind == "BLOCK" {
		sb.WriteString("  private isValidBlock(block: any): boolean {\n")
		sb.WriteString("    return block &&\n")
		sb.WriteString("           typeof block === \"object\" &&\n")
		sb.WriteString("           block.key &&\n")
		sb.WriteString("           block.keyType;\n")
		sb.WriteString("  }\n\n")

		if len(component.Events) > 0 {
			sb.WriteString("  public addAction(event: string, triggers: any[]): this {\n")
			sb.WriteString("    if (!this.isValidEvent(event)) {\n")
			sb.WriteString("      throw new Error(`Invalid event: ${event}. Must be one of: ${this.events.map((e) => e.event).join(\", \")}`);\n")
			sb.WriteString("    }\n")
			sb.WriteString("    const action: IAction = { event, triggers };\n")
			sb.WriteString("    this.actions.push(action);\n")
			sb.WriteString("    return this;\n")
			sb.WriteString("  }\n\n")
		}

		if len(component.Slots) > 0 {
			sb.WriteString("  public addBlock(block: any): this {\n")
			sb.WriteString("    if (!this.isValidBlock(block)) {\n")
			sb.WriteString("      throw new Error(\"Invalid block: Block must be an object with at least key and keyType\");\n")
			sb.WriteString("    }\n")
			sb.WriteString("    this.blocks.push(block);\n")
			sb.WriteString("    return this;\n")
			sb.WriteString("  }\n\n")
		}
	} else {
		sb.WriteString("  private isValidTrigger(trigger: ITrigger): boolean {\n")
		sb.WriteString("    return Boolean(trigger &&\n")
		sb.WriteString("           typeof trigger === \"object\" &&\n")
		sb.WriteString("           trigger.name &&\n")
		sb.WriteString("           trigger.keyType &&\n")
		sb.WriteString("           trigger.then);\n")
		sb.WriteString("  }\n\n")

		sb.WriteString("  public addTrigger(trigger: ITrigger): this {\n")
		sb.WriteString("    if (!this.isValidEvent(trigger.then)) {\n")
		sb.WriteString("      throw new Error(`Invalid then: ${trigger.then}. Must be one of: ${this.events.map((e) => e.event).join(\", \")}`);\n")
		sb.WriteString("    }\n")
		sb.WriteString("    if (!this.isValidTrigger(trigger)) {\n")
		sb.WriteString("      throw new Error(\"Invalid trigger: Trigger must be an object with name, keyType, and then\");\n")
		sb.WriteString("    }\n")
		sb.WriteString("    this.triggers.push({\n")
		sb.WriteString("      name: trigger.name,\n")
		sb.WriteString("      keyType: trigger.keyType,\n")
		sb.WriteString("      then: trigger.then,\n")
		sb.WriteString("      properties: trigger.properties || [],\n")
		sb.WriteString("      data: trigger.data || [],\n")
		sb.WriteString("      triggers: trigger.triggers || []\n")
		sb.WriteString("    });\n")
		sb.WriteString("    return this;\n")
		sb.WriteString("  }\n\n")
	}

	if len(component.Properties) > 0 {
		if kind == "BLOCK" {
			sb.WriteString("  public modifyProperty(key: string, valueMobile: string, valueTablet: string, valueDesktop: string): this {\n")
			sb.WriteString("    const propIndex = this.properties.findIndex((p) => p.key === key);\n")
			sb.WriteString("    if (propIndex !== -1) {\n")
			sb.WriteString("      this.properties[propIndex] = { ...this.properties[propIndex], valueMobile, valueTablet, valueDesktop };\n")
			sb.WriteString("    }\n")
			sb.WriteString("    return this;\n")
			sb.WriteString("  }\n\n")
		} else {
			sb.WriteString("  public modifyProperty(key: string, value: string): this {\n")
			sb.WriteString("    const propIndex = this.properties.findIndex((p) => p.key === key);\n")
			sb.WriteString("    if (propIndex !== -1) {\n")
			sb.WriteString("      this.properties[propIndex] = { ...this.properties[propIndex], value };\n")
			sb.WriteString("    }\n")
			sb.WriteString("    return this;\n")
			sb.WriteString("  }\n\n")
		}
	}

	if len(component.Data) > 0 {
		sb.WriteString("  public assignData(key: string, value: string): this {\n")
		sb.WriteString("    const dataIndex = this.data.findIndex((d) => d.key === key);\n")
		sb.WriteString("    if (dataIndex !== -1) {\n")
		sb.WriteString("      this.data[dataIndex] = { ...this.data[dataIndex], value };\n")
		sb.WriteString("    }\n")
		sb.WriteString("    return this;\n")
		sb.WriteString("  }\n\n")
	}

	sb.WriteString("  public build(): any {\n")
	sb.WriteString("    return {\n")
	sb.WriteString("      keyType: this.keyType,\n")
	if kind == "BLOCK" {
		sb.WriteString("      key: this.key,\n")
		sb.WriteString("      visibilityKey: this.visibilityKey,\n")
		sb.WriteString("      slot: this.slot,\n")
		sb.WriteString("      slots: this.slots,\n")
		sb.WriteString("      actions: this.actions,\n")
		sb.WriteString("      blocks: this.blocks,\n")
	} else {
		sb.WriteString("      name: this.name,\n")
		sb.WriteString("      then: this.then,\n")
		sb.WriteString("      triggers: this.triggers,\n")
	}
	sb.WriteString("      data: this.data,\n")
	sb.WriteString("      properties: this.properties,\n")
	sb.WriteString("      integrationVersion: this.integrationVersion,\n")
	sb.WriteString("    };\n")
	sb.WriteString("  }\n")

	sb.WriteString("}\n")

	return sb.String()
}

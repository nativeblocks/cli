package codeGenModule

import (
	"fmt"
	"strings"
)

func generateGoStruct(componentName string, component Integration, kind string) string {
	var sb strings.Builder

	sb.WriteString("// PLEASE DO NOT EDIT THIS FILE, THIS IS GENERATED BY NATIVEBLOCKS\n\n")
	sb.WriteString("package integration\n\n")

	sb.WriteString(fmt.Sprintf("type %sProperty struct {\n", componentName))
	if kind == "BLOCK" {
		sb.WriteString("\tKey          string `json:\"key\"`\n")
		sb.WriteString("\tValueMobile  string `json:\"valueMobile\"`\n")
		sb.WriteString("\tValueTablet  string `json:\"valueTablet\"`\n")
		sb.WriteString("\tValueDesktop string `json:\"valueDesktop\"`\n")
		sb.WriteString("\tType         string `json:\"type\"`\n")
	} else {
		sb.WriteString("\tKey   string `json:\"key\"`\n")
		sb.WriteString("\tValue string `json:\"value\"`\n")
		sb.WriteString("\tType  string `json:\"type\"`\n")
	}
	sb.WriteString("}\n\n")

	sb.WriteString(fmt.Sprintf("type %sData struct {\n", componentName))
	sb.WriteString("\tKey   string `json:\"key\"`\n")
	sb.WriteString("\tValue string `json:\"value\"`\n")
	sb.WriteString("\tType  string `json:\"type\"`\n")
	sb.WriteString("}\n\n")

	if kind == "BLOCK" {
		sb.WriteString(fmt.Sprintf("type %sAction struct {\n", componentName))
		sb.WriteString("\tEvent    string        `json:\"event\"`\n")
		sb.WriteString("\tTriggers []interface{} `json:\"triggers\"`\n")
		sb.WriteString("}\n\n")

		sb.WriteString(fmt.Sprintf("type %sSlot struct {\n", componentName))
		sb.WriteString("\tSlot string `json:\"slot\"`\n")
		sb.WriteString("}\n\n")
	} else {
		sb.WriteString(fmt.Sprintf("type %sTrigger struct {\n", componentName))
		sb.WriteString("\tName       string            `json:\"name\"`\n")
		sb.WriteString("\tKeyType    string            `json:\"keyType\"`\n")
		sb.WriteString("\tThen       string            `json:\"then\"`\n")
		sb.WriteString(fmt.Sprintf("\tProperties []%sProperty      `json:\"properties\"`\n", componentName))
		sb.WriteString(fmt.Sprintf("\tData       []%sData          `json:\"data\"`\n", componentName))
		sb.WriteString(fmt.Sprintf("\tTriggers   []%sTrigger      `json:\"triggers\"`\n", componentName))
		sb.WriteString("}\n\n")
	}

	sb.WriteString(fmt.Sprintf("type %sEvent struct {\n", componentName))
	sb.WriteString("\tEvent string `json:\"event\"`\n")
	sb.WriteString("}\n\n")

	sb.WriteString(fmt.Sprintf("type %s struct {\n", componentName))
	sb.WriteString("\tkeyType            string\n")
	sb.WriteString("\tintegrationVersion int\n")
	sb.WriteString(fmt.Sprintf("\tproperties         []%sProperty\n", componentName))
	sb.WriteString(fmt.Sprintf("\tdata               []%sData\n", componentName))
	sb.WriteString(fmt.Sprintf("\tevents             []%sEvent\n", componentName))

	if kind == "BLOCK" {
		sb.WriteString(fmt.Sprintf("\tactions            []%sAction\n", componentName))
		sb.WriteString("\tblocks             []interface{}\n")
		sb.WriteString(fmt.Sprintf("\tslots              []%sSlot\n", componentName))
		sb.WriteString("\tvisibilityKey      string\n")
		sb.WriteString("\tslot               string\n")
		sb.WriteString("\tkey                string\n")
	} else {
		sb.WriteString(fmt.Sprintf("\ttriggers           []%sTrigger\n", componentName))
		sb.WriteString("\tname               string\n")
		sb.WriteString("\tthen               string\n")
	}
	sb.WriteString("}\n\n")

	sb.WriteString(fmt.Sprintf("func New%s(", componentName))
	if kind == "BLOCK" {
		sb.WriteString("_key string,")
		sb.WriteString(" _visibilityKey string,")
		sb.WriteString(" _slot string")
	} else {
		sb.WriteString(" _name string,")
		sb.WriteString("  _then string")
	}
	sb.WriteString(fmt.Sprintf(") %s {\n", componentName))
	sb.WriteString(fmt.Sprintf("\tc := %s{} \n", componentName))
	sb.WriteString(fmt.Sprintf("\tc.keyType = \"%s\" \n", component.KeyType))
	if kind == "BLOCK" {
		sb.WriteString("\tc.key= _key\n")
		sb.WriteString("\tc.visibilityKey= _visibilityKey\n")
		sb.WriteString("\tc.slot= _slot\n")
		sb.WriteString("\tc.actions= make([]" + componentName + "Action, 0)\n")
		sb.WriteString("\tc.blocks= make([]interface{}, 0)\n")
	} else {
		sb.WriteString("\tc.name= _name\n")
		sb.WriteString("\tc.then= _then\n")
		sb.WriteString("\tc.triggers= make([]" + componentName + "Trigger, 0)\n")
	}

	sb.WriteString(fmt.Sprintf("\tinitialProperties := []%sProperty{\n", componentName))
	for _, prop := range component.Properties {
		if kind == "BLOCK" {
			sb.WriteString(fmt.Sprintf("\t\t{Key: \"%s\", ValueMobile: \"%s\", ValueTablet: \"%s\", ValueDesktop: \"%s\", Type: \"%s\"},\n",
				prop.Key, prop.Value, prop.Value, prop.Value, prop.Type))
		} else {
			sb.WriteString(fmt.Sprintf("\t\t{Key: \"%s\", Value: \"%s\", Type: \"%s\"},\n",
				prop.Key, prop.Value, prop.Type))
		}
	}
	sb.WriteString("\t}\n")
	sb.WriteString("\tc.properties = initialProperties\n\n")

	sb.WriteString(fmt.Sprintf("\tinitialData := []%sData{\n", componentName))
	for _, data := range component.Data {
		sb.WriteString(fmt.Sprintf("\t\t{Key: \"%s\", Value: \"\", Type: \"%s\"},\n", data.Key, data.Type))
	}
	sb.WriteString("\t}\n")
	sb.WriteString("\tc.data = initialData\n\n")

	if kind == "BLOCK" {
		sb.WriteString(fmt.Sprintf("\tinitialSlots := []%sSlot{\n", componentName))
		for _, slot := range component.Slots {
			sb.WriteString(fmt.Sprintf("\t\t{Slot: \"%s\"},\n", slot.Slot))
		}
		sb.WriteString("\t}\n")
		sb.WriteString("\tc.slots = initialSlots\n\n")
	}

	sb.WriteString(fmt.Sprintf("\tinitialEvents := []%sEvent{\n", componentName))
	if kind != "BLOCK" && len(component.Events) == 0 {
		sb.WriteString("\t\t{Event: \"END\"},\n")
	} else {
		for _, event := range component.Events {
			sb.WriteString(fmt.Sprintf("\t\t{Event: \"%s\"},\n", event.Event))
		}
	}
	sb.WriteString("\t}\n")
	sb.WriteString("\tc.events = initialEvents\n\n")
	sb.WriteString("\treturn c\n")
	sb.WriteString("}\n\n")

	sb.WriteString(fmt.Sprintf("func (c *%s) isValidEvent(eventName string) bool {\n", componentName))
	sb.WriteString("\tfor _, e := range c.events {\n")
	sb.WriteString("\t\tif e.Event == eventName {\n")
	sb.WriteString("\t\t\treturn true\n")
	sb.WriteString("\t\t}\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\treturn false\n")
	sb.WriteString("}\n\n")

	if kind == "BLOCK" {
		sb.WriteString(fmt.Sprintf("func (c *%s) isValidBlock(block interface{}) bool {\n", componentName))
		sb.WriteString("\tif block == nil {\n")
		sb.WriteString("\t\treturn false\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\tm, ok := block.(map[string]interface{})\n")
		sb.WriteString("\tif !ok {\n")
		sb.WriteString("\t\treturn false\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\t_, hasKey := m[\"key\"]\n")
		sb.WriteString("\t_, hasKeyType := m[\"keyType\"]\n")
		sb.WriteString("\treturn hasKey && hasKeyType\n")
		sb.WriteString("}\n\n")

		if len(component.Events) > 0 {
			sb.WriteString(fmt.Sprintf("func (c *%s) AddAction(event string, triggers []interface{}) *%s {\n", componentName, componentName))
			sb.WriteString("\tif !c.isValidEvent(event) {\n")
			sb.WriteString("\t\tvar eventNames string\n")
			sb.WriteString("\t\tfor _, ev := range c.events {\n")
			sb.WriteString("\t\t\teventNames += ev.Event \n")
			sb.WriteString("\t\t}\n")
			sb.WriteString("\t\tpanic(\"Invalid event: \" + event + \". Must be one of: \" + eventNames)\n")
			sb.WriteString("\t}\n")
			sb.WriteString(fmt.Sprintf("\taction := %sAction{Event: event, Triggers: triggers}\n", componentName))
			sb.WriteString("\tc.actions = append(c.actions, action)\n")
			sb.WriteString("\treturn c\n")
			sb.WriteString("}\n\n")
		}

		if len(component.Slots) > 0 {
			sb.WriteString(fmt.Sprintf("func (c *%s) AddBlock(block interface{}) *%s {\n", componentName, componentName))
			sb.WriteString("\tif !c.isValidBlock(block) {\n")
			sb.WriteString("\t\tpanic(\"Invalid block: Block must be a map with at least key and keyType\")\n")
			sb.WriteString("\t}\n")
			sb.WriteString("\tc.blocks = append(c.blocks, block)\n")
			sb.WriteString("\treturn c\n")
			sb.WriteString("}\n\n")
		}
	} else {
		sb.WriteString(fmt.Sprintf("func (c *%s) AddTrigger(trigger %sTrigger) *%s {\n", componentName, componentName, componentName))
		sb.WriteString("\tif !c.isValidEvent(trigger.Then) {\n")
		sb.WriteString("\t\tvar eventNames string\n")
		sb.WriteString("\t\tfor _, ev := range c.events {\n")
		sb.WriteString("\t\t\teventNames += ev.Event \n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\tpanic(\"Invalid then: \" + trigger.Then + \". Must be one of: \" + eventNames)\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\tc.triggers = append(c.triggers, trigger)\n")
		sb.WriteString("\treturn c\n")
		sb.WriteString("}\n\n")
	}

	if len(component.Properties) > 0 {
		if kind == "BLOCK" {
			sb.WriteString(fmt.Sprintf("func (c *%s) ModifyProperty(key, valueMobile, valueTablet, valueDesktop string) *%s {\n", componentName, componentName))
			sb.WriteString("\tfor i, p := range c.properties {\n")
			sb.WriteString("\t\tif p.Key == key {\n")
			sb.WriteString("\t\t\tc.properties[i].ValueMobile = valueMobile\n")
			sb.WriteString("\t\t\tc.properties[i].ValueTablet = valueTablet\n")
			sb.WriteString("\t\t\tc.properties[i].ValueDesktop = valueDesktop\n")
			sb.WriteString("\t\t\tbreak\n")
			sb.WriteString("\t\t}\n")
			sb.WriteString("\t}\n")
			sb.WriteString("\treturn c\n")
			sb.WriteString("}\n\n")
		} else {
			sb.WriteString(fmt.Sprintf("func (c *%s) ModifyProperty(key, value string) *%s {\n", componentName, componentName))
			sb.WriteString("\tfor i, p := range c.properties {\n")
			sb.WriteString("\t\tif p.Key == key {\n")
			sb.WriteString("\t\t\tc.properties[i].Value = value\n")
			sb.WriteString("\t\t\tbreak\n")
			sb.WriteString("\t\t}\n")
			sb.WriteString("\t}\n")
			sb.WriteString("\treturn c\n")
			sb.WriteString("}\n\n")
		}
	}

	if len(component.Data) > 0 {
		sb.WriteString(fmt.Sprintf("func (c *%s) AssignData(key, value string) *%s {\n", componentName, componentName))
		sb.WriteString("\tfor i, d := range c.data {\n")
		sb.WriteString("\t\tif d.Key == key {\n")
		sb.WriteString("\t\t\tc.data[i].Value = value\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\treturn c\n")
		sb.WriteString("}\n\n")
	}

	sb.WriteString(fmt.Sprintf("func (c *%s) Build() map[string]interface{} {\n", componentName))
	sb.WriteString("\tresult := map[string]interface{}{\n")
	sb.WriteString("\t\t\"keyType\":            c.keyType,\n")
	sb.WriteString("\t\t\"integrationVersion\": c.integrationVersion,\n")
	sb.WriteString("\t\t\"properties\":         c.properties,\n")
	sb.WriteString("\t\t\"data\":              c.data,\n")

	if kind == "BLOCK" {
		sb.WriteString("\t\t\"key\":               c.key,\n")
		sb.WriteString("\t\t\"visibilityKey\":     c.visibilityKey,\n")
		sb.WriteString("\t\t\"slot\":              c.slot,\n")
		sb.WriteString("\t\t\"slots\":             c.slots,\n")
		sb.WriteString("\t\t\"actions\":           c.actions,\n")
		sb.WriteString("\t\t\"blocks\":            c.blocks,\n")
	} else {
		sb.WriteString("\t\t\"name\":              c.name,\n")
		sb.WriteString("\t\t\"then\":              c.then,\n")
		sb.WriteString("\t\t\"triggers\":          c.triggers,\n")
	}

	sb.WriteString("\t}\n")
	sb.WriteString("\treturn result\n")
	sb.WriteString("}\n")

	return sb.String()
}
